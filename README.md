# sprint1.2
Sprint 1.2 del IT Academy

Voy a estudiar el FACTORY METHOD PATTERN

Los patrones de diseño son formas de resolver problemas típicos en la programación, formas de resolverlos que han sido aceptadas como muy buenas, muy elegantes. Los problemas que resuelven, también, son problemas de nuevo típicos, que pueden encontrarse muy a menudo en casos de programación. Por lo que he visto, los patrones de diseño son soluciones que aspiran a ser abstractas, cuanto más abstractas mejor. Por eso, resuelven problemas tan típicos, porque el problema que resuelven es un problema tan común que puede encontrarse en multitud de formas diferentes, de ahí su abstracción. Si fuesen menos abstractos, se aplicarían a menos casos y serían menos útiles para más gente.

Por lo que veo, los patrones de diseño son soluciones a problemas de programación, y a su vez los algoritmos también son soluciones a problemas, o formas de ingeniar un programa que resuelva una pregunta. La diferencia es que los algoritmos son como recetas de cocina, puedes seguir los pasos perfectamente pero cada resultado, cada pastel que cocinemos, no se verá completo hasta que no sigamos los pasos. Para ser más exactos, diríamos que los algoritmos, tal y como lo he entendido, quieren llegar al pastel a través de una serie de pasos muy concretos que alcanzan crear ese pastel. Los patrones de diseño son como una foto de un pastel: puedes ver el pastel completo, puedes ver cómo tiene que ser el resultado, pero luego tú decides qué pasos vas a seguir y en qué orden. Tal vez, al ver la foto y ver que es un pastel con cerezas encima, te decides por empezar a cortar las cerezas y a prepararlas. Otra persona podría ver esa foto y pensar que lo más óptimo sería empezar por el bizcocho, pero en todo caso ambas personas pueden llegar a crear ese pastel, porque ven qué es lo que quieren crear, y pueden dirigirse en esta dirección. De echo, lo bueno de eso es que se adapta a una multitud de formas distintas de problemas, por eso su abstracción. En los algoritmos, estamos dando una serie de pasos muy concreta, y si tú quieres empezar por las cerezas, no puedes en ese caso si el algoritmo empieza por las otras partes.

El Factory Method Pattern es una solución para el siguiente problema: un programa en el que queremos instanciar distintos tipos de objeto en una misma clase, e instanciarlos de maneras distintas, además.

Por ejemplo, me parece fácil el ejemplo del videojuego: tenemos un videojuego en el que aparecen enemigos en distintos lugares y tiempos. Pero los enemigos que aparecen son distintos: es decir, hay enemigos Pato, enemigos Perro, enemigos Gato. Todos son Enemigos, pertenecen a una clase Enemigo. Asimismo, se instancian de formas distintas, la lógica con la que se instancian es variante. En algunos casos, se instancia uno de estos tres tipos aleatoriamente, por ejemplo, y aparece un Gato, Perro o Pato indistintamente por la pantalla. En otras ocasiones se instancia el tipo de Enemigo al que más vulnerable seas tú, quien juega. Si tienes un traje, en el juego, que te protege de los Perros, puede que aparezcan más Patos para poderte acorralar con más facilidad, etc.

Sin usar este patrón, por ejemplo, sería seguramente un lío dejar pre-escrito en el código qué tipo de Enemigo instanciar en cada caso. Antes de ponernos a jugar el juego, no sabemos qué trajes de protección llevará el jugador, qué pritecciones hacia los Perros, Gatos o Patos tiene, por lo que no sabríamos qué Enemigo crear en cada moment. Depende totalmente de la jugada. Por lo tanto, sin el patrón deberíamos repetir la lógica descrita arriba, que podría llegar a ser muchas líneas de código, en muchas partes del código. El Factory Method Pattern permite crear una clase Factory, por ejemplo, que se encarga de crear enemigos.

Esta clase Factory puede encapsular las lógicas de creación, o así lo entiendo. Todo el código de aleatoriedad puede estar escrito una sola vez en un Factory.

La clase Factory debería ser, por lo tanto, una clase abstracta ya que nunca tendremos, en nuestro ejemplo, solo un Factory. Tendremos tipos de Factory concretos, como FactoryAleatorio o FactoryEnemigoDañino (para los enemigos que más dañan a quien juega, como dijimos anteriormente arriba). A su vez, olvidé decir que los Enemigos también serían una clase abstracta, ya que en el juego nuncá existirá un Enemigo sin tipo, siempre sería un EnemigoPato, un EnemigoPerro, o un EnemigoGato, etc, etc.

El FactoryAleatorio podría generar aleatoriamente Perros, Gatos o Patos. El FactoryEnemigoDañino podría generar el enemigo que más daño cause al jugador en ese momento, dadas sus circunstancias. Así evitamos escribir todo ese código una y otra vez durante el juego. Hasta podríamos, supongo, hacer aleatoria la aparición de Factories, para que no sepamos qué tipo de Factory va a aparecer en cada situación. En ese caso la clase abstracta Factory nos es de mucha utilidad.

Otra cosa que podríamos hacer es pasarle parámetros a la clase abstracta Factory para determinar qué tipo de Factory concreto vamos a crear. A su vez, esto determina qué tipos de Enemigos van a ser creados. Podríamos, por ejemplo, pasarle por parámetro ciertas cirunstancias del jugador. Su nivel de energía, las protecciones que tiene activadas, por ejemplo. Podríamos, entonces, activar el FactoryEnemigoDañino solamente si el jugador tiene suficiente vida, porque no queremos torturarlo sin necesidad si no puede soportarlo. Si tiene poca vida y pocas protecciones, la clase Factory abstracta solo creará FactoryAleatorio. Si el enemigo tiene vida y mucha protección, tendremos FactoryEnemigoDañino, para darle un extra de dificultad a sus cirunstancias.

En este caso, no solo hemos podido reducir las líneas de código y repeticiones, sino que además hemos modificado el diseño del juego para que el juego decida por sí mismo, podríamos decir, lo que tiene que instanciar y cuándo lo tiene que instanciar, etc.

HE ESCRITO UN PEQUEÑO EJEMPLO EN JAVASCRIPT, AÑADIDO A ESTE REPOSITORIO, DE CÓMO LO USARÍA MÁS O MENOS. ES UNA WEB SENCILLA, EN FORMATO HTML
